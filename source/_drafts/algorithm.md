---
title: 算法
date: 2018-12-19 20:30:29
tags: 算法
---
最近在看《算法导论》，再巩固一遍对于算法这一块的认识，特此记录每一种排序算法的实现与思想。

# 交换
```c++
// 常规
int x = 3;
int y = 5;
int temp = x;   // temp 3
x = y;	// x 5
y = temp;	// y 3

// 加减法，比常规少用一个临时变量
int x = 10;
int y = 5;
x = x + y;   // x 15
y = x - y;   // y 10
x = x - y;   // x 5

// 异或，比较有趣，也比较难记住
int x = 10; // x 0000 1010
int y = 5;  // y 0000 0101
x = x ^ y;  // x 0000 1111
y = x ^ y;  // y 0000 1010
x = x ^ y;  // x 0000 0101
```


# 排序
## 冒泡排序
```c++
void bubble_sort(vector<int> v){
    int end = v.size();
    while(end > 1){
        int new_end = 0;
        for(int j=0; j<end-1; j++){
            if(v[j] > v[j+1]){
                swap(v[j], v[j+1]);
                new_end = j+1;
            } 
        }
        end = new_end;
    }
}

// 3, 1, 4, 6, 7, 9, 5 --- origin   3和1交换，9和5交换↓
// 1, 3, 4, 6, 7, 5, 9 --- end index: 6 最后一次交换位置，是9和5交换的位置 
// 1, 3, 4, 6, 5, 7, 9 --- end index: 5 最后一次交换位置，是7和5交换的位置
// 1, 3, 4, 5, 6, 7, 9 --- end index: 4 最后一次交换位置，是6和5交换的位置
// 1, 3, 4, 5, 6, 7, 9 --- end index: 0 在这个例子中，最后一次不需要交换
```
这是优化后的冒泡排序。
思想：记录最后一次交换的位置，因为在后面的序列，都是已经经过排序，无需再次检查。
时间复杂度：O(n^2)
空间复杂度：O(1) (常数)
***
# 插入排序
```c++
void insertion_sort(vector<int> v){
    for(int i = 1; i < v.size(); ++i){
        int tmp = v[i], j = i - 1;
        for(; j >= 0 && v[j] > tmp; --j){
            v[j+1] = v[j];
        }
        v[j+1] = tmp;
    }
}

/*
5, 4, 8, 7, 3 --- 第一位排序
4, 5, 8, 7, 3 --- 前两位排序
4, 5, 8, 7, 3 --- 前三位排序
4, 5, 7, 8, 3 --- 前四位排序
这里描述下过程：
4, 5, 7, 8,   --- 3被提出来，保存到tmp=3
4, 5, 7,  , 8 --- 从第五位开始往前数，逐个对比后往后写。
4, 5,  , 7, 8
4,  , 5, 7, 8
 , 4, 5, 7, 8 --- 排完之后，插入到空位位置。
3, 4, 5, 7, 8 --- 前五位排序 */
```
思路：
1. 认为第一个元素是排好序的，从第二个开始遍历。
2. 拿出当前元素的值，从排好序的序列中从后往前找。
3. 如果序列中的元素比当前元素大，就把它后移。直到找到一个小的。
4. 把当前元素放在这个小的后面（后面的比当前大，它已经被后移了）。

时间复杂度：O(n^2)
空间复杂度：O(1) (常数)

## 选择排序
```c++
SELECTION-SORT(A):
  for i = 1 to A.length - 1
      min = i
      for j = i + 1 to A.length
          if A[j] < A[min]
              min = j
      temp = A[i]
      A[i] = A[min]
      A[min] = temp
```
思路：从前n-1个数开始遍历，第一次拿出最小值，与第一个数值交换；第二次拿出次小值，与第二个位置数值交换，一直循环下去。
时间复杂度：O(n^2)

## 归并排序
归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。
这里不花篇幅记录了，具体参考：[图解归并排序](https://www.cnblogs.com/chengxiao/p/6194356.html)

## 霍纳规则(Horner's rule) (秦九韶算法)
[使用霍纳规则计算多项式](https://blog.csdn.net/mountzf/article/details/51870696)
```c++
int horner(int *a, int n,int x) //霍纳规则
{
    int ax = a[n] * x + a[n - 1];   //求出在内层括号内的值
    for(int i = n - 2; i >= 0; i--) //循环求出多项式在x处的值
    {
        ax = ax * x + a[i];
    }
    return ax;
}
```

